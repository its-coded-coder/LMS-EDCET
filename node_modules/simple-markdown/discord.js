        return r({}, e, {
            s: {
                order: e.u.order,
                match: s.default.inlineRegex(/^~~([\s\S]+?)~~(?!_)/),
                parse: e.u.parse
            },
            url: r({}, e.url, {
                match: s.default.inlineRegex(/^((https?|steam):\/\/[^\s<]+[^<.,:;"')\]\s])/)
            }),
            emoji: {
                order: s.default.defaultRules.text.order,
                match: function(e) {
										//               /^:([^\s:]+?(?:::skin\-tone\-\d)?):/
                    return c.default.EMOJI_NAME_AND_DIVERSITY_RE.exec(e)
                },
                parse: function(e) {
                    var t = e[0]
                      , n = e[1]
                      , o = c.default.convertNameToSurrogate(n);
                    return o ? {
                        name: ":" + n + ":",
                        surrogate: o,
                        src: g.default.getURL(o)
                    } : {
                        type: "text",
                        content: t
                    }
                }
            },
            customEmoji: {
                order: s.default.defaultRules.text.order,
                match: function(e) {
                    return /^<:(\w+):(\d+)>/.exec(e)
                },
                parse: function(e, t, n) {
                    var o = (e[0],
                    e[1])
                      , a = e[2]
                      , r = n.guildId
                      , i = u.default.getDisambiguatedEmojiContext(r).getById(a)
                      , s = !i || i.require_colons;
                    return i && (o = i.name),
                    {
                        emojiId: a,
                        name: s ? ":" + o + ":" : o,
                        src: p.default.getEmojiURL({
                            id: a
                        })
                    }
                }
            },
            text: r({}, e.text, {
                parse: function(e, t, n) {
                    return n.nested ? {
                        content: e[0]
                    } : t(c.default.translateSurrogatesToInlineEmoji(e[0]), r({}, n, {
                        nested: !0
                    }))
                }
            })
        })

// more ???

    function r(e) {
        return s({}, e, {
            s: s({}, e.s, {
                react: function(e, t, n) {
                    return i("s", {}, n.key, t(e.content, n))
                }
            }),
            highlight: {
                order: e.text.order,
                match: function() {
                    return null
                },
                react: function(e, t, n) {
                    return i("span", {
                        className: "highlight"
                    }, n.key, e.content)
                }
            },
            paragraph: s({}, e.paragraph, {
                react: function(e, t, n) {
                    return i("p", {}, n.key, t(e.content, n))
                }
            }),
            link: s({}, e.link, {
                react: function(e, t, n) {
                    var o = (0,
                    L.findInvite)(e.target)
                      , a = void 0
                      , r = t(e.content, n)
                      , s = e.title || (0,
                    R.astToString)(e.content)
                      , l = !1
                      , f = I.default.getChannel(M.default.getChannelId());
                    return null != f && f.type === m.ChannelTypes.DM && (l = !N.default.isFriend(f.getRecipientId())),
                    null != o && (a = function(e) {
                        e && e.preventDefault(),
                        D.default.acceptInviteAndTransitionToInviteChannel(o, "Markdown Link")
                    }
                    ),
                    s != e.target || l ? i(Y.default, {
                        title: s,
                        href: u.default.sanitizeUrl(e.target),
                        onConfirm: s != e.target ? function() {
                            return window.open(e.target, "_blank")
                        }
                        : null
                    }, n.key, r) : i("a", {
                        title: s,
                        href: u.default.sanitizeUrl(e.target),
                        target: "_blank",
                        rel: "noreferrer",
                        onClick: a
                    }, n.key, r)
                }
            }),
            emoji: s({}, e.emoji, {
                react: function(e, t, n) {
                    return e.src ? i(k.default, {
                        text: e.name,
                        delay: 750,
                        position: k.default.Positions.TOP
                    }, n.key, i("img", {
                        draggable: !1,
                        className: (0,
                        g.default)("emoji", {
                            jumboable: e.jumboable
                        }),
                        alt: e.name,
                        src: e.src
                    })) : i("span", {}, n.key, e.surrogate)
                }
            }),
            customEmoji: s({}, e.customEmoji, {
                react: function(e, t, n) {
                    var o = n.key
                      , a = n.guildId;
                    return i(k.default, {
                        text: function() {
                            var t = _.default.getDisambiguatedEmojiContext(a).getById(e.emojiId);
                            if (t) {
                                return !t || t.require_colons ? ":" + t.name + ":" : t.name
                            }
                            return e.name
                        },
                        delay: 750,
                        position: k.default.Positions.TOP
                    }, o, i("img", {
                        draggable: !1,
                        className: (0,
                        g.default)("emoji", {
                            jumboable: e.jumboable
                        }),
                        alt: e.name,
                        src: e.src
                    }))
                }
            }),
            mention: s({}, e.mention, {
                handleUserContextMenu: function(e, t, n, o) {
                    j.default.openContextMenu(o, function(o) {
                        return c.default.createElement(W.default, s({}, o, {
                            type: m.ContextMenuTypes.USER_CHANNEL_MENTION,
                            user: e,
                            channelId: t,
                            guildId: n
                        }))
                    })
                },
                react: function(e, t, n) {
                    var o = {
                        className: "mention"
                    }
                      , a = "span";
                    if (e.color && (a = V.default,
                    o.color = e.color),
                    !e.userId)
                        return c.default.createElement(a, s({
                            key: n.key
                        }, o), t(e.content, n));
                    var r = S.default.getUser(e.userId)
                      , l = I.default.getChannel(e.channelId)
                      , u = l ? l.getGuildId() : null;
                    return u && (o.onContextMenu = this.handleUserContextMenu.bind(this, r, e.channelId, u)),
                    i(x.default, {
                        closeOnScroll: !1,
                        render: function(t) {
                            return c.default.createElement(G.default, s({}, t, {
                                user: r,
                                guildId: u,
                                channelId: e.channelId
                            }))
                        },
                        position: x.default.Positions.RIGHT
                    }, n.key, c.default.createElement(a, o, t(e.content, n)))
                }
            }),
            channel: s({}, e.channel, {
                handleClick: function(e, t) {
                    null != e && null != t && E.default.transitionTo(m.Routes.CHANNEL(e, t))
                },
                react: function(e, t, n) {
                    var o = i("span", {
                        onClick: this.handleClick.bind(this, e.guildId, e.channelId),
                        className: "mention"
                    }, n.key, t(e.content, n))
                      , a = I.default.getChannel(e.channelId)
                      , r = I.default.getChannel(null != a ? a.parent_id : null);
                    return null != r && (o = i(k.default, {
                        text: r.toString(),
                        position: k.default.Positions.TOP
                    }, n.key, o)),
                    o
                }
            }),
            inlineCode: s({}, e.inlineCode, {
                react: function(e, t, n) {
                    return i("code", {
                        className: "inline"
                    }, n.key, a(e, t, n))
                }
            }),
            codeBlock: s({}, e.codeBlock, {
                react: function(e, t, n) {
                    if (e.lang && null != p.default.getLanguage(e.lang)) {
                        var o = p.default.highlight(e.lang, e.content, !0);
                        return i("pre", {}, n.key, i("code", {
                            className: Q.default.scrollbarGhost + " hljs " + o.language,
                            dangerouslySetInnerHTML: {
                                __html: o.value
                            }
                        }))
                    }
                    return i("pre", {}, n.key, i("code", {
                        className: Q.default.scrollbarGhost + " hljs"
                    }, void 0, a(e, t, n)))
                }
            }),
            text: s({}, e.text, {
                react: function(e, t, n) {
                    return "string" == typeof e.content ? e.content : i("span", {}, n.key, t(e.content, n))
                }
            })
        })
    }

